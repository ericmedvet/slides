class: center, middle

## "Advanced" Input/Output (I/O)
### with streams

---

## Basic I/O

We already know how to do I/O
- of basic types (primitive and `String`s)
- from/to stdin/stdin

```java
BufferedReader reader = new BufferedReader(
  new InputStreamReader(System.in)
);
/* ... */
String line = reader.readLine();
```

```java
Scanner scanner = new Scanner(System.in);
/* ... */
String s = scanner.next();
int n = scanner.nextInt();
double d = scanner.nextDouble();
```
What about other types and other source/target devices?

---

## Asbtraction I/O stream

Two basic models:
- **output** stream to device where data can be written as `byte[]`
- **input** stream from a device where data can be read as `byte[]`

Usage (key steps):
1. create the stream associating with the device
2. read or write `byte[]`

Device: file, "network", ...

.cols[
.c50[
.diagram.logic.center[
cyl(0,70,180,40,'Device','device')
cyl(10,30,160,40,'Output stream')
arrow(90,10,60,40)
text(90,-20,'byte[]','code')
]
]
.c50[
.diagram.logic.center[
cyl(0,70,180,40,'Device','device')
cyl(10,30,160,40,'Input stream')
arrow(90,10,60,40,180)
text(90,-20,'byte[]','code')
]
]
]

---

## Beyond basic models

Other more complex models in which there is some **processing** of the data:
- compression/decompression of `byte[]`
- transformation of `byte[]` to/from other types
- ...

---

## `InputStream` and `OutputStream`

All I/O streams extend one between `InputStream` and `OutputStream`.

They can be composed:
- a stream can be build over another stream: the "result" is still a stream (of the same direction)
- data stream through streams .note(an instance of the **filter pattern**)

.cols[
.c50.center[
.diagram.logic[
cyl(0,150,80,30,'','device')
cyl(10,120,60,30)
arrow(40,110,40,20)
cyl(100,150,80,30,'','device')
cyl(110,120,60,30)
cyl(110,90,60,30)
arrow(140,80,40,20)
cyl(200,150,80,30,'','device')
cyl(210,120,60,30)
cyl(210,90,60,30)
cyl(210,60,60,30)
arrow(240,50,40,20)
]
Composition of `OutputStream`s
]
.c50.center[
.diagram.logic[
cyl(0,150,80,30,'','device')
cyl(10,120,60,30)
arrow(40,110,40,20,180)
cyl(100,150,80,30,'','device')
cyl(110,120,60,30)
cyl(110,90,60,30)
arrow(140,80,40,20,180)
cyl(200,150,80,30,'','device')
cyl(210,120,60,30)
cyl(210,90,60,30)
cyl(210,60,60,30)
arrow(240,50,40,20,180)
]
Composition of `InputStream`s
]
]

---

## Point of view of the "user"

No need to change the code .note[the "user" of the stream is a developer]:
- for **different devices** $\leftarrow$ polymorphism
- for **different processings** $\leftarrow$ polymorphism
- also for more complex (wrt `byte[]`) data types $\leftarrow$ composition

.diagram.logic.center[
cyl(0,150,80,30,'','device')
cyl(10,120,60,30)
arrow(40,110,40,20)
cyl(100,150,80,30,'','device')
cyl(110,120,60,30)
cyl(110,90,60,30)
arrow(140,80,40,20)
cyl(200,150,80,30,'','device')
cyl(210,120,60,30)
cyl(210,90,60,30)
cyl(210,60,60,30)
arrow(240,50,40,20)
]

---

## How many I/O streams?

A lot!

We'll see a subset, for most common
- devices
- data transformation
- processing

---

class:middle,center

### I/O of `byte[]`

---

## `OutputStream` class

.javadoc[
This **abstract** class is the superclass of all classes representing an output stream of bytes. An output stream **accepts output bytes and sends them to some sink**.
]

Methods:
.javadoc.methods[
| Mod. and Type | Method | Description |
| --- | --- | --- |
| void | close() | Closes this output stream and releases any system resources associated with this stream. |
| void | flush() | Flushes this output stream and forces any buffered output bytes to be written out. |
|static OutputStream| nullOutputStream() | Returns a new `OutputStream` which discards all bytes. |
| void | write​(byte[] b) | Writes `b.length` bytes from the specified byte array to this output stream. |
| void | write​(byte[] b, int off, int len) | Writes `len` bytes from the specified byte array starting at offset `off` to this output stream. |
| abstract void | write​(int b) | Writes the specified byte to this output stream. |
]

- Writes only `byte[]`
- Subclasses take devices .note[`OutputStream` is abstract, cannot be instantiated]
  - `OutputStream.nullOutputStream()` gives a device discarding written `byte[]`

---

## Writing `byte[]`

`OutputStream` class:
.javadoc.methods[
| Mod. and Type | Method | Description |
| --- | --- | --- |
| void | write​(byte[] b, int off, int len) | Writes `len` bytes from the specified byte array starting at offset `off` to this output stream. |

Writes `len` bytes from the specified byte array starting at offset `off` to this output stream. The general contract for `write(b, off, len)` is that some of the bytes in the array `b` are written to the output stream in order; element `b[off]` is the first byte written and `b[off+len-1]` is the last byte written by this operation.
]

`write(b)` is the same as `write(b, 0, b.length)`

---

## Use of `write(byte[])`

```java
byte[] data = /* ... */
OutputStream os = /* ... */
os.write(data, 0, 10); //`A`
os.write(data, 10, 20); //`B`
```

The device abstraction (might be a real device, or another `OutputStream`) of `os`:
- just after A:
  - contains 10 bytes
  - next write will start at position 10 (0-indexes)
- just after B:
  - contains 30 bytes
  - next write will start at position 30

---

### Subclass of `OutputStream`

`write​(byte[] b, int off, int len)`
.javadoc[
**The general contract** for `write(b, off, len)` is that some of the bytes in the array `b` are written to the output stream in order; element `b[off]` is the first byte written and `b[off+len-1]` is the last byte written by this operation.
]

"The general contract is [...]": a message for:
1. the developer extending `OutputStream`
2. the curious user (another developer)
  - that can, in principle, ignore how the stream writes the data

`write(byte[] b)`
.javadoc[
**The general contract** for `write(b)` is that it should have exactly the same effect as the call `write(b, 0, b.length)`.
]

---

### Extending `OutputStream`

In principle, just `write(int b)` can be overridden!
.note[Actually, **must** be, we'll see...]
(In class description)
> Applications that need to define a subclass of `OutputStream` must always provide at least a method that writes one byte of output.

But: (In `write​(byte[] b, int off, int len)`)
> The `write` method of `OutputStream` calls the write method of one argument on each of the bytes to be written out. Subclasses are **encouraged** to override this method and provide a **more efficient** implementation.

---

<!-- piece of code that show write many based on write one -->

<!-- discussion about why int -->
