class: center, middle

## "Advanced" Input/Output (I/O)
### with streams

---

## Basic I/O

We already know how to do I/O
- of basic types (primitive and `String`s)
- from/to stdin/stdout

```java
BufferedReader reader = new BufferedReader(
  new InputStreamReader(System.in)
);
/* ... */
String line = reader.readLine();
```

```java
Scanner scanner = new Scanner(System.in);
/* ... */
String s = scanner.next();
int n = scanner.nextInt();
double d = scanner.nextDouble();
```
What about other types and other source/target devices?

---

## Abstraction: I/O stream

Stream: endpoints, direction, type of data
- a stream of X between A and B

Two basic models:
- **output** stream to device where data can be written as `byte[]`
- **input** stream from a device where data can be read as `byte[]`

.cols[
.c50[
.diagram.io.center[
cyl(0,70,180,40,'Device','device')
cyl(10,30,160,40,'Output stream')
arrow(90,10,60,40)
text(90,-20,'byte[]','code')
]
]
.c50[
.diagram.io.center[
cyl(0,70,180,40,'Device','device')
cyl(10,30,160,40,'Input stream')
arrow(90,10,60,40,180)
text(90,-20,'byte[]','code')
]
]
]

---

## Interaction with a stream

Usage (key steps):
1. create the stream associating with the device
2. read or write `byte[]`

Device: file, "network", ...

---

## Beyond basic models

Other more complex models in which there is some **processing** of the data:
- compression/decompression of `byte[]`
- transformation of `byte[]` to/from other types
- ...

---

## `InputStream` and `OutputStream`

All I/O streams extend one between `InputStream` and `OutputStream`.

They can be composed:
- a stream can be build over another stream: the "result" is still a stream (of the same direction)
- data stream through streams .note[an instance of the **filter pattern**]
- each stream "is" the device for the stream above

.cols[
.c50.center[
.diagram.io[
cyl(0,150,80,30,'','device')
cyl(10,120,60,30)
arrow(40,110,40,20)
cyl(100,150,80,30,'','device')
cyl(110,120,60,30)
cyl(110,90,60,30)
arrow(140,80,40,20)
cyl(200,150,80,30,'','device')
cyl(210,120,60,30)
cyl(210,90,60,30)
cyl(210,60,60,30)
arrow(240,50,40,20)
]
Composition of `OutputStream`s
]
.c50.center[
.diagram.io[
cyl(0,150,80,30,'','device')
cyl(10,120,60,30)
arrow(40,110,40,20,180)
cyl(100,150,80,30,'','device')
cyl(110,120,60,30)
cyl(110,90,60,30)
arrow(140,80,40,20,180)
cyl(200,150,80,30,'','device')
cyl(210,120,60,30)
cyl(210,90,60,30)
cyl(210,60,60,30)
arrow(240,50,40,20,180)
]
Composition of `InputStream`s
]
]

---

## Point of view of the "user"

No need to change the code .note[the "user" of the stream is a developer]:
- for **different devices** $\leftarrow$ polymorphism
- for **different processings** $\leftarrow$ polymorphism
- also for more complex (wrt `byte[]`) data types $\leftarrow$ composition

.diagram.io.center[
cyl(0,150,80,30,'','device')
cyl(10,120,60,30)
arrow(40,110,40,20)
cyl(100,150,80,30,'','device')
cyl(110,120,60,30)
cyl(110,90,60,30)
arrow(140,80,40,20)
cyl(200,150,80,30,'','device')
cyl(210,120,60,30)
cyl(210,90,60,30)
cyl(210,60,60,30)
arrow(240,50,40,20)
]

---

## How many I/O streams?

A lot!

We'll see a subset, for most common
- devices
- data transformation
- processing

---

class:middle,center

### I/O of `byte[]`

---

## `OutputStream` class

.javadoc[
This **abstract** class is the superclass of all classes representing an output stream of bytes. An output stream **accepts output bytes and sends them to some sink**.
]

Methods:
.javadoc.methods[
| Mod. and Type | Method | Description |
| --- | --- | --- |
| void | close() | Closes this output stream and releases any system resources associated with this stream. |
| void | flush() | Flushes this output stream and forces any buffered output bytes to be written out. |
|static OutputStream| nullOutputStream() | Returns a new `OutputStream` which discards all bytes. |
| void | write​(byte[] b) | Writes `b.length` bytes from the specified byte array to this output stream. |
| void | write​(byte[] b, int off, int len) | Writes `len` bytes from the specified byte array starting at offset `off` to this output stream. |
| abstract void | write​(int b) | Writes the specified byte to this output stream. |
]

- Writes only `byte[]`
- Subclasses take devices .note[`OutputStream` is abstract, cannot be instantiated]
  - `OutputStream.nullOutputStream()` gives a device discarding written `byte[]`

---

## Writing `byte[]`

`OutputStream` class:
.javadoc.methods[
| Mod. and Type | Method | Description |
| --- | --- | --- |
| void | write​(byte[] b, int off, int len) | Writes `len` bytes from the specified byte array starting at offset `off` to this output stream. |

Writes `len` bytes from the specified byte array starting at offset `off` to this output stream. The general contract for `write(b, off, len)` is that some of the bytes in the array `b` are written to the output stream in order; element `b[off]` is the first byte written and `b[off+len-1]` is the last byte written by this operation.
]

Other methods:
- `write(b)` is the same as `write(b, 0, b.length)`

---

## Use of `write()`

```java
byte[] data = /* ... */
OutputStream os = /* ... */
os.write(data, 0, 3); //`A`
os.write(data, 3, 2); //`B`
os.write(new byte[2]); //`C`
```

The device abstraction (might be a real device, or another `OutputStream`) of `os`:
- after A: contains 3 bytes; next write will start at 3 (0-indexes)
- after B: 5 bytes; **cursor** (= next write) at 5
- after C: 7 bytes; cursor at 7

.diagram.io.center[
cyl(0,10,160,60)
arrow(80,-10,60,30)
array(10,40,20,20,3,3)
cyl(200,10,160,60)
arrow(280,-10,60,30)
array(210,40,20,20,5,5)
cyl(400,10,160,60)
arrow(480,-10,60,30)
array(410,40,20,20,7,7)
]

---

### Subclasses of `OutputStream`

`write​(byte[] b, int off, int len)`
.javadoc[
**The general contract** for `write(b, off, len)` is that some of the bytes in the array `b` are written to the output stream in order; element `b[off]` is the first byte written and `b[off+len-1]` is the last byte written by this operation.
]

"The general contract is [...]": a message for:
1. the developer extending `OutputStream`
2. the curious user (another developer)
  - who can, in principle, ignore how the stream writes the data

`write(byte[] b)`
.javadoc[
**The general contract** for `write(b)` is that it should have exactly the same effect as the call `write(b, 0, b.length)`.
]

---

### Extending `OutputStream`

In principle, just `write(int b)` can be overridden!
.note[Actually, **must** be, we'll see...]
(In class description)
> Applications that need to define a subclass of `OutputStream` must always provide at least a method that writes one byte of output.

But: (In `write​(byte[] b, int off, int len)`)
> The `write` method of `OutputStream` calls the write method of one argument on each of the bytes to be written out. Subclasses are **encouraged** to override this method and provide a **more efficient** implementation.

---

### Internals

```java
public void write(byte[] b, int off, int len) {
  for (int i = off; i<off+len; i++) {
    write(b[i]);
  }
}
```

> Subclasses are **encouraged** to override this method and provide a **more efficient** implementation.

Means:  
if there is a fixed cost (overhead) in writing on the device, regardless of data size, write more than one bytes at once

---

## Associating with a device

File:
```java
OutputStream os = new FileOutputStream(/* ... */);
byte[] data = /* ... */
os.write(data);
```

Network (TCP):
```java
Socket socket = /* ... */
OutputStream os = socket.getOutputStream();
byte[] data = /* ... */
os.write(data);
```

Memory:
```java
OutputStream os = new ByteArrayOutputStream();
byte[] data = /* ... */
os.write(data);
```

---

## `FileOutputStream`

.javadoc.head[
**Package** .pack[java.io]

.def[Class FileOutputStream]

.pack[java.lang.Object]  
.indent[].pack[java.io.OutputStream]  
.indent[].indent[]java.io.FileOutputStream
]
.javadoc[
A file output stream is an output stream for writing data to a `File` or to a `FileDescriptor`. Whether or not a file is available or may be created depends upon the underlying platform. Some platforms, in particular, allow a file to be opened for writing by only one `FileOutputStream` (or other file-writing object) at a time. In such situations the constructors in this class will fail if the file involved is already open.
]

"depends upon the underlying platform": there is still a physical machine under the JVM!

Constructors:
.javadoc.constructors[
| Constructor | Description |
| --- | --- |
| FileOutputStream​(File file) | Creates a file output stream to write to the file represented by the specified `File` object. |
| FileOutputStream​(File file, boolean append) | Creates a file output stream to write to the file represented by the specified `File` object. |
| FileOutputStream​(String name) | Creates a file output stream to write to the file with the specified name. |
| FileOutputStream​(String name, boolean append) | Creates a file output stream to write to the file with the specified name. |
]

---

## From `Socket`

`Socket` class:
.javadoc.methods[
| Mod. and Type | Method | Description |
| --- | --- | --- |
| OutputStream | getOutputStream() | Returns an output stream for this socket. |
]

The user does not need to know the actual class of the output stream returned by `getOutputStream()`.

---

## `ByteArrayOutputStream`

.javadoc.head[
**Package** .pack[java.io]

.def[Class ByteArrayOutputStream]

.pack[java.lang.Object]  
.indent[].pack[java.io.OutputStream]  
.indent[].indent[]java.io.ByteArrayOutputStream
]
.javadoc[
This class implements an output stream in which the data is written into a byte array. The buffer automatically grows as data is written to it. The data can be retrieved using `toByteArray()` and `toString()`.
]
.javadoc.methods[
| Mod. and Type | Method | Description |
| --- | --- | --- |
| int | size() | Returns the current size of the buffer. |
| byte[] | toByteArray() | Creates a newly allocated byte array. |
]

Usage:
```java
ByteArrayOutputStream baos = new ByteArrayOutputStream();
byte[] data = /* ... */
baos.write(data);
byte[] written = baos.toByteArray();
System.out.println(Arrays.equals(data, written)); // -> true
```

Why? As a fake device, to do to `byte[]` conversion, ...

---

## End of Stream (EOS)

- A logical marker saying that there is no data after it
- Inserted by `close()`

```java
byte[] data = /* ... */
OutputStream os = /* ... */
os.write(data, 0, 3); //`A`
os.close(); //`B`
```
.diagram.io.center[
cyl(0,10,160,60)
arrow(80,-10,60,30)
array(10,40,20,20,3,3)
cyl(200,10,160,60)
arrow(280,-10,60,30)
array(210,40,20,20,4,'',3)
]

Usually, no other `write()` are possible after EOS has written.

---

### EOS and `close()`

From `OutputStream.close()`:
> Closes this output stream and releases any system resources associated with this stream. **The general contract** of `close` is that it closes the output stream. A closed stream cannot perform output operations and cannot be reopened.

> The `close` method of `OutputStream` does nothing.

`OutputStream` is the base class, no specific device:
- "system resources" are the device
- "Closing a `ByteArrayOutputStream` has no effect. The methods in this class can be called after the stream has been closed [...]"

---

## `InputStream` class

.javadoc[
This abstract class is the superclass of all classes representing an input stream of bytes.
]

Methods (some):
.javadoc.methods[
| Mod. and Type | Method | Description |
| --- | --- | --- |
| abstract int | read() | Reads the next byte of data from the input stream. |
| int | read​(byte[] b) | Reads some number of bytes from the input stream and stores them into the buffer array `b`. |
| int | read​(byte[] b, int off, int len) | Reads up to `len` bytes of data from the input stream into an array of bytes. |
]

- Reads only `byte[]`
- Subclasses take devices .note[`InputStream` is abstract, cannot be instantiated]
  - `InputStream.nullInputStream()` gives a device with no bytes to read (EOS is at position 0)

---

## Reading `byte[]`

.javadoc[
.methods[
| Mod. and Type | Method | Description |
| --- | --- | --- |
| int | read​(byte[] b, int off, int len) | Reads up to `len` bytes of data from the input stream into an array of bytes. |
]

Reads up to `len` bytes of data from the input stream into an array of bytes. An attempt is made to read as many as `len` bytes, but a smaller number may be read. The number of bytes actually read is returned as an integer.
]

Attempt? We'll see...

Other methods:
- `read(b)` is the same as `read(b, 0, b.length)`
- ...

---

## Use of `read()`


```java
byte[] buffer = new byte[100];
InputStream is = /* ... */ //`A`
is.read(buffer, 0, 4); //`B`
is.read(buffer, 4, 1); //`C`
```

The device abstraction (might be a real device, or another `InputStream`) of `is`:
- after A: cursor at 0
- after B: cursor at 4
- after C: cursor at 5

.diagram.io.center[
cyl(0,10,160,60)
arrow(80,-10,60,30,180)
array(10,40,20,20,7,0,6)
cyl(200,10,160,60)
arrow(280,-10,60,30,180)
array(210,40,20,20,7,4,6)
cyl(400,10,160,60)
arrow(480,-10,60,30,180)
array(410,40,20,20,7,5,6)
]

---

## Associating with a device

File:
```java
InputStream is = new FileInputStream(/* ... */);
byte[] buffer = new byte[100];
is.read(buffer, 0, 10);
```

Network (TCP):
```java
Socket socket = /* ... */
InputStream is = socket.getInputStream();
byte[] buffer = new byte[100];
is.read(buffer, 0, 10);
```

Memory:
```java
InputStream is = new ByteArrayInputStream(/* ... */);
byte[] buffer = new byte[100];
is.read(buffer, 0, 10);
```

---

## `FileInputStream`

.javadoc.head[
**Package** .pack[java.io]

.def[Class FileInputStream]

.pack[java.lang.Object]  
.indent[].pack[java.io.InputStream]  
.indent[].indent[]java.io.FileInputStream
]
.javadoc[
A `FileInputStream` obtains input bytes from a file in a file system. What files are available depends on the host environment.
]

Constructors:
.javadoc.constructors[
| Constructor | Description |
| --- | --- |
| FileInputStream​(File file) | Creates a FileInputStream by opening a connection to an actual file, the file named by the File object file in the file system. |
| FileInputStream​(String name) | Creates a FileInputStream by opening a connection to an actual file, the file named by the path name name in the file system. |
]

Note: no `boolean append`! (obviously)

---

## `ByteArrayInputStream`

.javadoc.head[
**Package** .pack[java.io]

.def[Class ByteArrayInputStream]

.pack[java.lang.Object]  
.indent[].pack[java.io.InputStream]  
.indent[].indent[]java.io.ByteArrayInputStream
]
.javadoc[
A `ByteArrayInputStream` contains an internal buffer that contains bytes that may be read from the stream. An internal counter keeps track of the next byte to be supplied by the read method.
]

"contains an internal buffer" $\rightarrow$ the device!

Constructors:
.javadoc.constructors[
| Constructor | Description |
| --- | --- |
| ByteArrayInputStream​(byte[] buf) | Creates a `ByteArrayInputStream` so that it uses `buf` as its buffer array. |
]

---

## Difference in abstraction

.cols[
.c50[
.center[
`OutputStream`
]

```java
os.write(new byte[2]);
os.write(new byte[3]);
```
.diagram.io.center[
cyl(0,10,140,60)
arrow(70,-10,60,30)
array(10,40,15,20,2,2)
cyl(150,10,140,60)
arrow(220,-10,60,30)
array(160,40,15,20,5,5)
]

No limit* on writeable data:
- no pre-existing EOS

\*: in principle
]
.c50[
.center[
`InputStream`
]

```java
is.read(new byte[2]);
is.read(new byte[3]);
```
.diagram.io.center[
cyl(0,10,140,60)
arrow(70,-10,60,30,180)
array(10,40,15,20,8,2,7)
cyl(150,10,140,60)
arrow(220,-10,60,30,180)
array(160,40,15,20,8,5,7)
]

Readable data is limited:
- an EOS exists!
]
]

---

### Input from files and `byte[]`

Input from file with `FileInputStream`:
- created with `FileInputStream(File file)` .note[we'll see a `File` is]
- the file exists, hence it has a size, hence a EOS

Input from `byte[]` with `ByteArrayInputStream`:
- created with `ByteArrayInputStream(byte[] data)`
- the data exists, hence it has a size, hence a EOS

---

### Output to files and `byte[]`

Output to file with `FileOutputStream`:
- created with, e.g., `FileOutputStream(File file, boolean append)`
- create the file (if not existing and possible), or write at the end of file $\rightarrow$ no limits to the writeable data!
  - possible limits related to underlying OS (obviously)

Output to `byte[]` with `ByteArrayOutputStream`:
- "The buffer automatically grows as data is written to it."

---

## Attempt of reading (with EOS)

.cols[
.c30[
.diagram.io.center[
cyl(0,10,140,60)
arrow(70,-10,60,30,180)
array(10,40,15,20,8,2,7)
]
]
.c70[
Before: device still contains 5 bytes, the EOS
```java
is.read(buf, 0, 2); //`OK!`
```
]
]

.cols[
.c30[
.diagram.io.center[
cyl(0,10,140,60)
arrow(70,-10,60,30,180)
array(10,40,15,20,8,4,7)
]
]
.c70[
Before: device still contains 3 bytes, then EOS
```java
is.read(buf, 0, 5); //`?`
```
]
]

---

## Attempt of reading (without EOS)

.cols[
.c30[
.diagram.io.center[
cyl(0,10,140,60)
arrow(70,-10,60,30,180)
array(10,40,15,20,7,4)
]
]
.c70[
Before: device contains 3 **ready** bytes
```java
is.read(buf, 0, 5); //`?`
```
Other data might arrive (be ready) in the future...
]
]

.cols[
.c30[
.diagram.io.center[
cyl(0,10,140,60)
arrow(70,-10,60,30,180)
array(10,40,15,20,4,4)
]
]
.c70[
Before: device contains no **ready** bytes
```java
is.read(buf, 0, 5); //`?`
```
Other data might arrive (be ready) in the future...
]
]

---

## `read()`

.javadoc[
.methods[
| Mod. and Type | Method | Description |
| --- | --- | --- |
| int | read​(byte[] b, int off, int len) | Reads up to `len` bytes of data from the input stream into an array of bytes. |
]

Reads up to `len` bytes of data from the input stream into an array of bytes. An attempt is made to read as many as `len` bytes, but **a smaller number may be read**. The number of bytes actually read is returned as an integer.

This method **blocks until input data is available, end of file is detected**, or an exception is thrown.

If `len` is zero, then no bytes are read and `0` is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at end of file, the value `-1` is returned; otherwise, at least one byte is read and stored into `b`.
]

Attempt to read `len` bytes:
- if next byte in device is EOS, return immediately -1
- if 0 bytes ready: block and wait for data
- if $\ge$ `len` ready, read `len` bytes and return immediately `len`
- otherwise, read $n <$ `len` bytes and return immediately $n$


---

### Example

Suppose the device:
- contains 5 bytes from time $t=0$ to $t=10$ (seconds)
- receives other 3 bytes, with a trailing EOS, at $t=10$

.cols[
.c60[
.diagram.io.center[
cyl(0,90,50,20)
arrow(25,85,20,10,180)
link([60,100,300,100,'>'],'axis')
link([80,95,80,105],'axis')
array(30,150,20,20,5,0)
link([80,140,80,110,'>'])
array(35,30,20,20,5,3)
array(35,-10,20,20,5,5)
link([85,60,85,90,'>'])
array(160,150,20,20,9,5,8)
link([250,140,250,110,'>'])
array(165,30,20,20,9,8,8)
array(165,-10,20,20,9,8,8)
link([255,60,255,90,'>'])
]
]
.c40[
```java
is.read(buf, 0, 3);
// t=0 -> t~0, ret 3
is.read(buf, 0, 3);
// t~0 -> t~0, ret 2
is.read(buf, 0, 3); // BLOCK!
// t~0 -> t~10, ret 3
is.read(buf, 0, 3);
// t~10 -> t~10, ret -1
```
]
]

---

## Blocking `read()`

"The device receives": the `InputStream` receives for the underlying level, eventually from a physical devices

Keyboard $\rightarrow$ `InputStream System.in`
- the user types (and hit enter) $\rightarrow$ `InputStream` receives bytes

Network connection $\rightarrow$ `InputStream getInputStream()`
- data from the network arrives to this socket $\rightarrow$ receives bytes

---

## Internally

`read​(byte[] b, int off, int len)` in `InputStream`:
> The `read(b, off, len)` method for class `InputStream` simply calls the method `read()` repeatedly.

.javadoc[
.methods[
| Mod. and Type | Method | Description |
| --- | --- | --- |
| abstract int | read() | Reads the next byte of data from the input stream. |
]
Reads the next byte of data from the input stream. The value byte is returned as an `int` in the range `0` to `255`. If no byte is available because the end of the stream has been reached, the value `-1` is returned. This method blocks until input data is available, the end of the stream is detected, or an exception is thrown.
]

`read()` read one `byte`, but returns an `int`: why?
- because the semantics of the return value includes a special value (`-1`) representing EOS
- domain of `byte` does not include `-1`!

---

### `-1` in `read()` and `write()`

Other alternatives for representing EOS:
- returning a `Byte`, `null` for EOS
  - object creation overhead; uses heap, slower
- throwing an exception .note[we ignore exceptions now; we'll see]
  - EOS is not an exception, indeed; it's the norm

Java inventors **chose** to use an `int` as return value
- for consistency `read(byte[], int, int)` also returns an `int`
- for consistency `write(int)` in `OutputStream` takes an `int`!

.javadoc[
.methods[
| Mod. and Type | Method | Description |
| --- | --- | --- |
| abstract void | write(int b) | Writes the specified byte to this output stream. |
]
Writes the specified byte to this output stream. The general contract for `write` is that one byte is written to the output stream. The byte to be written is the **eight low-order bits** of the argument `b`. The 24 high-order bits of `b` are ignored.
]

---

## `File`

Surprisingly, the `File` class does not represent a file!

.javadoc.head[
**Package** .pack[java.io]

.def[Class File]

.pack[java.lang.Object]  
.indent[]java.io.File
]
.javadoc[
An abstract representation of file and directory pathnames.

User interfaces and operating systems use system-dependent pathname strings to name files and directories. This class presents an abstract, system-independent view of hierarchical pathnames.
]

- "An abstract representation of file and directory **pathnames**".
- "system-independent view of hierarchical **pathnames**"

(a rather long description follows)

---

### `File` system-independent view

<iframe width="100%" height="500" src="https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/io/File.html"></iframe>

---

## Not a file!

No methods for reading and writing!

Methods for:
- removing, renaming, listing (`File` represents dirs too), ...

.javadoc.methods[
| Mod. and Type | Method | Description |
| --- | --- | --- |
| boolean | canExecute() | Tests whether the application can execute the file denoted by this abstract pathname. |
| boolean | canRead() | Tests whether the application can read the file denoted by this abstract pathname. |
| boolean | canWrite() | Tests whether the application can modify the file denoted by this abstract pathname. |
| boolean | delete() | Deletes the file or directory denoted by this abstract pathname. |
| boolean | exists() | Tests whether the file or directory denoted by this abstract pathname exists. |
| boolean | isDirectory() | Tests whether the file denoted by this abstract pathname is a directory. |
| String[] | list() | Returns an array of strings naming the files and directories in the directory denoted by this abstract pathname. |
| File[] | listFiles() | Returns an array of abstract pathnames denoting the files in the directory denoted by this abstract pathname. |
| boolean | mkdir() | Creates the directory named by this abstract pathname. |
| boolean | renameTo​(File dest) |Renames the file denoted by this abstract pathname. |
| boolean | setExecutable​(boolean executable) | A convenience method to set the owner's execute permission for this abstract pathname. |
]

---

### Open with `FileOutputStream`

`FileOutputStream​(File file)` and `FileOutputStream​(String name)`:
- if `file`/`name` does not exist, creates new one .note[if OS says it's possible]
- puts the cursor at 0

$\rightarrow$ **existing content is cancelled**!
- if you want to append, use the constructors with `boolean append`!
  - puts cursor at the position equal to the length of file

---

## Example: file copy

We want to develop an application that:
- receives two file names $f_1, f_2$ as command line arguments
- copies the content of file named $f_1$ to $f_2$
  - assume file $f_1$ exists and is readable
  - overwrite file $f_2$ if it exists

```bash
eric@cpu:~$ java FileCopier slides.zip copy-of-slides.zip
```

---

## Sketch

1. build `FileInputStream` from `String` $f_1$; build `FileOutputStream` from `String` $f_2$
2. iterate until EOS
  1. read `byte[]` from `FileInputStream`
  2. write `byte[]` to `FileOutputStream`

.diagram.io.center[
cyl(0,70,180,40,'OS file system','device')
cyl(10,30,160,40,'Input stream')
arrow(90,10,60,40,180)
text(90,-20,'byte[]','code')
cyl(300,70,180,40,'OS file system','device')
cyl(310,30,160,40,'Output stream')
arrow(390,10,60,40)
text(390,-20,'byte[]','code')
link([90,-30,90,-60,390,-60,390,-30,'>'])
]

---

### Stopping criterion

"Iterate until EOS"

Suppose to use a buffer of $n$ bytes (i.e., to read $n$ bytes for iteration):
- every iteration but second-last and last reads $n$ bytes
- second-last reads $\le n$
- last return `-1` $\rightarrow$ EOS

---

## Possible code

```java
public class FileCopier {
  public static void main(String[] args) throws FileNotFoundException, IOException {
    InputStream is = new FileInputStream(args[0]);
    OutputStream os = new FileOutputStream(args[1]);
    byte[] buffer = new byte[1024];
    while (true) {
      int nOfBytes = is.read(buffer);
      if (nOfBytes == -1) {
        break;
      }
      os.write(buffer, 0, nOfBytes);
    }
    is.close();
    os.close();
  }
}
```

.note[Ignore `throws FileNotFoundException, IOException` for now.]

---

### Make it more general

```java
public class Util {
  public static void copyAndClose(InputStream is, OutputStream os) throws FileNotFoundException, IOException {
    byte[] buffer = new byte[1024];
    while (true) {
      int nOfBytes = is.read(buffer);
      if (nOfBytes == -1) {
        break;
      }
      os.write(buffer, 0, nOfBytes);
    }
    is.close();
    os.close();
  }
}
```

`copyAndClose()` "ignores" the specific kind of streams (devices):
- while developing/compiling: inheritance
- while executing: polymorphism

---

class:middle,center

### I/O of primitive types

---

## Output with `DataOutputStream`

.javadoc.head[
**Package** .pack[java.io]

.def[Class DataOutputStream]

.pack[java.lang.Object]  
.indent[].pack[java.io.OutputStream]  
.indent[].indent[].pack[java.io.FilterOutputStream]  
.indent[].indent[].indent[]java.io.DataOutputStream
]
.javadoc[
A data output stream lets an application write primitive Java data types to an output stream in a portable way. An application can then use a data input stream to read the data back in.
]

.javadoc.constructors[
| Constructor | Description |
| --- | --- |
| DataOutputStream​(OutputStream out) | Creates a new data output stream to write data to the specified underlying output stream. |
]

.javadoc.methods[
| Mod. and Type | Method | Description |
| --- | --- | --- |
| void | writeDouble​(double v) | Converts the `double` argument to a `long` using the `doubleToLongBits` method in class `Double`, and then writes that `long` value to the underlying output stream as an 8-byte quantity, high byte first. |
| void | writeFloat​(float v) | Converts the `float` argument to an `int` using the `floatToIntBits` method in class `Float`, and then writes that `int` value to the underlying output stream as a 4-byte quantity, high byte first.|
| void | writeInt​(int v) | Writes an `int` to the underlying output stream as four bytes, high byte first. |
| void | writeLong​(long v) | Writes a `long` to the underlying output stream as eight bytes, high byte first. |
]

"converts [...] high byte first" $\rightarrow$ **portable way**

---

## Input with `DataInputStream`

.javadoc.head[
**Package** .pack[java.io]

.def[Class DataInputStream]

.pack[java.lang.Object]  
.indent[].pack[java.io.InputStream]  
.indent[].indent[].pack[java.io.FilterInputStream]  
.indent[].indent[].indent[]java.io.DataInputStream
]
.javadoc[
A data input stream lets an application read primitive Java data types from an underlying input stream in a machine-independent way. An application uses a data output stream to write data that can later be read by a data input stream.
]

.javadoc.constructors[
| Constructor | Description |
| --- | --- |
| DataInputStream​(InputStream in) | Creates a `DataInputStream` that uses the specified underlying `InputStream`. |
]

.javadoc.methods[
| Mod. and Type | Method | Description |
| --- | --- | --- |
| double | readDouble() | See the general contract of the `readDouble` method of `DataInput`. |
| float | readFloat() | See the general contract of the `readFloat` method of `DataInput`. |
| int | readInt() | See the general contract of the `readInt` method of `DataInput`. |
| long | readLong() | See the general contract of the `readLong` method of `DataInput`. |
]

"machine-independent" == "portable"

---

### Filter pattern

`DataOutputStream` extends `FilterOutputStream`
> This class is the superclass of all classes that filter output streams. These streams sit on top of an already existing output stream (the *underlying output stream*) which it uses as its basic sink of data, but possibly transforming the data along the way or providing additional functionality.

`DataInputStream` extends `FilterInputStream`
> A `FilterInputStream` contains some other input stream, which it uses as its basic source of data, possibly transforming the data along the way or providing additional functionality.

---

## Abstraction

.cols[
.c50[
.diagram.io.center[
cyl(0,70,270,40,'OS','device')
cyl(10,30,250,40,'OutputStream', 'code')
cyl(10,-10,250,40,'DataOutputStream', 'code')
arrow(135,-30,60,40)
text(135,-70,'writeDouble()','code')
text(135,-90,'writeBoolean()','code')
]
]
.c50[
.diagram.io.center[
cyl(0,70,270,40,'OS','device')
cyl(10,30,250,40,'InputStream', 'code')
cyl(10,-10,250,40,'DataInputStream', 'code')
arrow(135,-30,60,40,180)
text(135,-70,'readDouble()','code')
text(135,-90,'readBoolean()','code')
]
]
]

---

## Portability

Java developers built `DataInputStream` and `DataOutputStream` together:
- they read and write primitive types to `byte[]` accordingly
- every machine reads/write `byte[]` in the same way

$\Rightarrow$ portability!

E.g.:
- file written on a OS is readable from another OS
- data sent via socket is readable on the other endpoint

But...

---

## Portability vs. protocol

Portability is granted for the single data item!

At the application level, parties (reader and writer) have to act accordingly!
- in practice, they have to share a protocol

---

### "Real-life" example

Alice and Bob meet on chat:
- A: tell me your age, weight, and annual net income in k€
- B: 65, 95, 40
- A: 🙅

Creative Bob:
- B (unfair): 40, 65, 95
- A: 😻

What happened?
- each single number was correctly communicated!
- application protocol (order) was not respected (in the 2nd case)
  - with this data, Alice has no way for telling if Bob is complying the protocol!
  - maybe with other data, e.g., 20, 75, 40

---

### Java streams example

.cols[
.c50[
Application saves data on file:
.diagram.io.center[
cyl(0,70,270,40,'OS file system','device')
cyl(10,30,250,40,'OutputStream', 'code')
cyl(10,-10,250,40,'DataOutputStream', 'code')
arrow(135,-30,60,40)
text(135,-70,'writeInt()','code')
text(135,-90,'writeDouble()','code')
text(135,-110,'writeInt()','code')
]
Writes 16 bytes:
- 4 for 1st `int`
- 8 for `double`
- 4 for 2nd `int`
]
.c50[
Application loads same file:
.diagram.io.center[
cyl(0,70,270,40,'OS file system','device')
cyl(10,30,250,40,'InputStream', 'code')
cyl(10,-10,250,40,'DataInputStream', 'code')
arrow(135,-30,60,40,180)
text(135,-70,'readInt()','code')
text(135,-90,'readFloat()','code')
text(135,-110,'readInt()','code')
]
Reads 12 bytes:
- 4 for 1st `int`
- **4** for `float`
- **4** for 2nd `int`
]
]

---

### Disaster!

.cols[
.c50[
Writes 16 bytes:
- 4 for 1st `int`
- 8 for `double`
- 4 for 2nd `int`
]
.c50[
Reads 12 bytes:
- 4 for 1st `int`
- **4** for `float`
- **4** for 2nd `int`
]
]

Read data "is different" than written data:
- and no way to realize it at runtime

---

class: lab
name: exercise3

## File array .note[~3h]

1. Design and implement a class `FileArray` that mantains a **binary file-backed** array of `int` values, with constructors/methods to:
  - build a new array with $n$ random values $\sim U(\\{0,\dots,2^{10}\\})$
  - load an existing array
  - print the array
  - increment all elements of the arrays
2. Write an application that "uses" `FileArray`
  - receives $m \ge 1$ parameters at command read
  - 1st is a file pathname
      - if not existing, create with $n \sim U(\\{1,\dots,2^5\\})$, otherwise, load
  - from 2nd on, a list of one-char commands:
      - `i` for increment
      - `p` for print

---

class: lab

### `FileArray`

```java
public class FileArray {
  // loads an existing file
  public FileArray(String filePathName) { /* ... */ }
  // creates new file with n random elements
  public FileArray(String filePathName, int n) { /* ... */ }
  // pretty print with at most 5 aligned elements per row
  public void print();
  //increment all elements
  public void incrementAll();
}
```
Hints:
- for (pseudo)random generation, see [`Random`](https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Random.html)`.nextInt()`
- "ignore" exceptions
- use two "internal" methods:
  - read: file $\rightarrow$ `int[]`
  - write: `int[]` $\rightarrow$ file
  - e.g.: print=read,print; incrementAll=read,inc,write

---

class: lab

### Application using `FileArray`

Assuming `test.bin` exists with 8 values:

```bash
eric@cpu:~$ java FileArrayTester test.bin p i i p
[0-4]  8 73 12  4 99
[5-8] 18  6 78
[0-4]  10  75  14   6 101
[5-8]  20   8  80
```
And the file content is left accordingly.

Note:
- **alignment** and **indexes**
- column width is the shortest possible (2 at 1st `p`, 3 at 2nd `p`)

Hint: use `printf` or `String.format()`, e.g., `%3d`

---

## Compression with `GZIPOutputStream`

.javadoc.head[
**Package** .pack[java.io]

.def[Class DataOutputStream]

.pack[java.lang.Object]  
.indent[].pack[java.io.OutputStream]  
.indent[].indent[].pack[java.io.FilterOutputStream]  
.indent[].indent[].indent[].pack[java.util.zip.DeflaterOutputStream]  
.indent[].indent[].indent[].indent[]java.util.zip.GZIPOutputStream
]
.javadoc[
This class implements a stream filter for writing compressed data in the GZIP file format.
]

.javadoc.constructors[
| Constructor | Description |
| --- | --- |
| GZIPOutputStream​(OutputStream out) | Creates a new output stream with a default buffer size. |
]

.javadoc.methods[
| Mod. and Type | Method | Description |
| --- | --- | --- |
| void | finish() | Finishes writing compressed data to the output stream without closing the underlying stream. |
| void | write​(byte[] buf, int off, int len) | Writes array of bytes to the compressed output stream. |
]

---

## Decompression with `GZIPInputStream`

.javadoc.head[
**Package** .pack[java.io]

.def[Class DataOutputStream]

.pack[java.lang.Object]  
.indent[].pack[java.io.InputStream]  
.indent[].indent[].pack[java.io.FilterInputStream]  
.indent[].indent[].indent[].pack[java.util.zip.DeflaterInputStream]  
.indent[].indent[].indent[].indent[]java.util.zip.GZIPInputStream
]
.javadoc[
This class implements a stream filter for reading compressed data in the GZIP file format.
]

.javadoc.constructors[
| Constructor | Description |
| --- | --- |
| GZIPInputStream​(InputStream in) | Creates a new input stream with a default buffer size. |
]

.javadoc.methods[
| Mod. and Type | Method | Description |
| --- | --- | --- |
| void | close() | Closes this input stream and releases any system resources associated with the stream. |
| int | read​(byte[] buf, int off, int len) | Reads uncompressed data into an array of bytes. |
]

---

## GZIP vs. zip

There are also `ZipOutputStream` and `ZipInputStream`:
- `GZIP` streams "just" compress/decompress binary data
- `Zip` streams operate with files
  - they can contain files and directories

---

class: lab
name: exercise4

## GZIP file array .note[~1h, 3rd home assign.]

1. Design and implement a class `GZIPFileArray` that **extends** `FileArray` and mantains a **compressed** binary file-backed array of `int` values
  - with same functionalities of `FileArray` (see [specifications](#exercise3))
2. Write an application that "uses" `FileArray` or `GZIPFileArray`
  - receives $m \ge 1$ parameters at command read
  - 1st is a file pathname
      - if not existing, create with $n \sim U(\\{1,\dots,2^5\\})$, otherwise, load
      - if filename ends with `.zip`, use `GZIPFileArray`, otherwise use `FileArray`
  - from 2nd on, a list of one-char commands (see [specifications](#exercise3))

---

class: middle,center

### Buffered I/O

---

## OS and I/O

.cols[
.c70[
Most devices are actually managed by the OS:
- OS performs reads and writes of data chunks of a size $s_o$ that depends on the OS and the devices
  - e.g., 8 KB for files on disk
- invoking OS **is heavy**

Applications may need to read/write data chunks with size $s_a \ne s_o$
- if $s_a < s_o$, OS is invoked more often than needed  
$\rightarrow$ inefficiency!
]
.c30[
.diagram.io.center[
text(90,-20,'Application')
cyl(0,110,180,40,'Device','device')
cyl(0,70,180,40,'OS','device')
cyl(10,30,160,40,'Output stream')
arrow(90,10,60,40)
]
]
]

---

### Writes to device

.diagram.io.center[
text(90,-20,'Application')
cyl(0,110,180,40,'Device','device')
cyl(0,70,180,40,'OS','device')
cyl(10,30,160,40,'OutputStream', 'code')
arrow(90,10,60,40)
]

Application to `OutputStream`:
- `write()` 100 bytes, `write()` 1000 bytes, `write()` 100 bytes

`OutputStream` (JVM) to OS:
- `write()` 100 bytes, `read()` 1000 bytes, `write()` 100 bytes

OS to device:
- hopefully something optimal

---

## Solution: buffered stream

A filter stream with a **buffer**.

Output:
1. takes write requests as usual
2. puts them in a buffer
3. makes write requests to the underlying stream when buffer is full

Input:
1. takes read requests as usual
2. if in buffer, take from buffer, otherwise fill the buffer with a read from underlying stream

---

### Writes to device with buffer

Assume buffer of 1000 bytes.

.diagram.io.center[
text(140,-60,'Application')
cyl(0,110,280,40,'Device','device')
cyl(0,70,280,40,'OS','device')
cyl(10,30,260,40,'OutputStream', 'code')
cyl(10,-10,260,40,'BufferedOutputStream', 'code')
arrow(140,-30,60,40)
]

Application to `BufferedOutputStream`:
- `write()` 100 bytes, `write()` 1000 bytes, `write()` 100 bytes, ...

`BufferedOutputStream` to `OutputStream` and `OutputStream` to OS:
- `write()` 1000 bytes, ...

---

### Reads from device with buffer

Assume buffer of 1000 bytes.

.diagram.io.center[
text(140,-60,'Application')
cyl(0,110,280,40,'Device','device')
cyl(0,70,280,40,'OS','device')
cyl(10,30,260,40,'InputStream', 'code')
cyl(10,-10,260,40,'BufferedInputStream', 'code')
arrow(140,-30,60,40,180)
]

Application to `BufferedInputStream`:
- `read()` 100 bytes, `read()` 1000 bytes, `read()` 100 bytes, ...

`BufferedInputStream` to `InputStream` and `InputStream` to OS:
- `read()` 1000 bytes, `read()` 1000 bytes, ...
